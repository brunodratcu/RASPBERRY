"""font = {
    # NÚMEROS
    '0': [0x3C, 0x66, 0x6A, 0x72, 0x66, 0x66, 0x3C, 0x00],
    '1': [0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00],
    '2': [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00],
    '3': [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00],
    '4': [0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00],
    '5': [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00],
    '6': [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00],
    '7': [0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00],
    '8': [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00],
    '9': [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00],
    
    # SÍMBOLOS
    ':': [0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00],
    '/': [0x00, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00],
    '-': [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
    '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
    ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    
    # MAIÚSCULAS
    'A': [0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
    'B': [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00],
    'C': [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00],
    'D': [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00],
    'E': [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00],
    'F': [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00],
    'G': [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00],
    'H': [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
    'I': [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
    'J': [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00],
    'K': [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00],
    'L': [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00],
    'M': [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00],
    'N': [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00],
    'O': [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
    'P': [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00],
    'Q': [0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00],
    'R': [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00],
    'S': [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00],
    'T': [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
    'U': [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
    'V': [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
    'W': [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],
    'X': [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00],
    'Y': [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00],
    'Z': [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00],
    
    # MINÚSCULAS
    'a': [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00],
    'b': [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00],
    'c': [0x00, 0x00, 0x3C, 0x60, 0x60, 0x60, 0x3C, 0x00],
    'd': [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00],
    'e': [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00],
    'f': [0x0E, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00],
    'g': [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x7C],
    'h': [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00],
    'i': [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00],
    'j': [0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x66, 0x3C],
    'k': [0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00],
    'l': [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
    'm': [0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00],
    'n': [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00],
    'o': [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00],
    'p': [0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60],
    'q': [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06],
    'r': [0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00],
    's': [0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00],
    't': [0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x0E, 0x00],
    'u': [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00],
    'v': [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
    'w': [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00],
    'x': [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00],
    'y': [0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x0C, 0x78],
    'z': [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00],
}

# === CONFIGURAÇÕES WIFI ===
WIFI_SSID = "iPhone A C Dratcu"      # Altere para seu WiFi
WIFI_PASSWORD = "s7wgr4dobgdse"  # Altere para sua senha
"""

# main.py - Magic Mirror - Com Sincronização WiFi
import machine
import utime
import ujson
import ubluetooth
import gc
import network
import urequests
from machine import Pin, RTC

print("MAGIC MIRROR - Iniciando...")

# === CONFIGURAÇÕES WIFI ===
WIFI_SSID = "SEU_WIFI_AQUI"      # Altere para seu WiFi
WIFI_PASSWORD = "SUA_SENHA_AQUI"  # Altere para sua senha

# === HARDWARE CORRETO ===
rtc = RTC()

# Função para conectar WiFi
def conectar_wifi():
    """Conecta ao WiFi"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    
    if wlan.isconnected():
        print("WiFi já conectado!")
        return True
    
    print(f"Conectando WiFi: {WIFI_SSID}...")
    wlan.connect(WIFI_SSID, WIFI_PASSWORD)
    
    # Aguarda conexão (máximo 10 segundos)
    timeout = 10
    while timeout > 0:
        if wlan.status() < 0 or wlan.status() >= 3:
            break
        timeout -= 1
        print("Conectando...")
        utime.sleep(1)
    
    if wlan.isconnected():
        print(f"WiFi conectado! IP: {wlan.ifconfig()[0]}")
        return True
    else:
        print("ERRO: Falha ao conectar WiFi!")
        return False

# Função para sincronizar horário via API
def sincronizar_horario():
    """Sincroniza horário via API WorldTimeAPI"""
    try:
        print("Sincronizando horário...")
        
        # API para horário de São Paulo, Brasil
        url = "http://worldtimeapi.org/api/timezone/America/Sao_Paulo"
        response = urequests.get(url)
        
        if response.status_code == 200:
            data = response.json()
            datetime_str = data["datetime"]  # formato: 2024-12-25T17:30:45.123456-03:00
            
            # Extrai data e hora da string
            date_part, time_part = datetime_str.split("T")
            time_part = time_part.split(".")[0]  # remove microssegundos
            
            # Parse da data
            ano, mes, dia = map(int, date_part.split("-"))
            
            # Parse da hora
            hora, minuto, segundo = map(int, time_part.split(":"))
            
            # Configura RTC
            # Formato: (ano, mês, dia, dia_semana, hora, minuto, segundo, subsegundo)
            # dia_semana será calculado automaticamente
            rtc.datetime((ano, mes, dia, 0, hora, minuto, segundo, 0))
            
            print(f"Horário sincronizado: {dia:02d}/{mes:02d}/{ano} {hora:02d}:{minuto:02d}:{segundo:02d}")
            response.close()
            return True
            
        else:
            print(f"ERRO API: Status {response.status_code}")
            response.close()
            return False
            
    except Exception as e:
        print(f"ERRO na sincronização: {e}")
        return False

# Função para inicializar com horário correto
def inicializar_horario():
    """Inicializa o sistema com horário correto"""
    print("=== INICIALIZANDO HORÁRIO ===")
    
    # Tenta conectar WiFi
    if conectar_wifi():
        # Tenta sincronizar horário
        if sincronizar_horario():
            print("✅ Horário sincronizado com sucesso!")
            return True
        else:
            print("❌ Falha na sincronização")
    else:
        print("❌ Sem WiFi disponível")
    
    # Fallback: define horário padrão
    print("⚠️  Usando horário padrão...")
    rtc.datetime((2024, 12, 25, 2, 16, 30, 0, 0))
    return False

# Inicializa horário na inicialização
inicializar_horario()

# Pinos display CORRETOS
rst = Pin(16, Pin.OUT, value=1)  # GP16
cs = Pin(17, Pin.OUT, value=1)   # GP17
rs = Pin(15, Pin.OUT, value=0)   # GP15
wr = Pin(19, Pin.OUT, value=1)   # GP19
rd = Pin(18, Pin.OUT, value=1)   # GP18
data_pins = [Pin(i, Pin.OUT) for i in [0,1,2,3,4,5,6,7]]  # GP0-GP7

# Botão
btn = Pin(21, Pin.IN, Pin.PULL_UP)  # GP21

# Cores
BLACK = 0x0000
WHITE = 0xFFFF
RED = 0xF800
GREEN = 0x07E0
YELLOW = 0xFFE0
CYAN = 0x07FF

# Estado
display_on = True
events = []
ble_connected = False

# === DISPLAY ===
def write_byte(data):
    for i in range(8):
        data_pins[i].value((data >> i) & 1)

def cmd(c):
    cs.value(0); rs.value(0); write_byte(c)
    wr.value(0); wr.value(1); cs.value(1)

def dat(d):
    cs.value(0); rs.value(1); write_byte(d)
    wr.value(0); wr.value(1); cs.value(1)

def init_lcd():
    rst.value(0); utime.sleep_ms(50); rst.value(1); utime.sleep_ms(50)
    cmd(0x01); utime.sleep_ms(100)
    cmd(0x11); utime.sleep_ms(100)
    cmd(0x3A); dat(0x55)
    cmd(0x36); dat(0xE8)
    cmd(0x29); utime.sleep_ms(50)

def set_area(x0, y0, x1, y1):
    cmd(0x2A); dat(x0>>8); dat(x0&0xFF); dat(x1>>8); dat(x1&0xFF)
    cmd(0x2B); dat(y0>>8); dat(y0&0xFF); dat(y1>>8); dat(y1&0xFF)
    cmd(0x2C)

def fill_rect(x, y, w, h, color):
    if not display_on or w<=0 or h<=0: return
    set_area(x, y, x+w-1, y+h-1)
    ch, cl = color>>8, color&0xFF
    cs.value(0); rs.value(1)
    for _ in range(w*h):
        write_byte(ch); wr.value(0); wr.value(1)
        write_byte(cl); wr.value(0); wr.value(1)
    cs.value(1)

# === FONTE BITMAP SIMPLES ===
font = {
    # NÚMEROS
    '0': [0x3C, 0x66, 0x6A, 0x72, 0x66, 0x66, 0x3C, 0x00],
    '1': [0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00],
    '2': [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00],
    '3': [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00],
    '4': [0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00],
    '5': [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00],
    '6': [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00],
    '7': [0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00],
    '8': [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00],
    '9': [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00],
    
    # SÍMBOLOS
    ':': [0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00],
    '/': [0x00, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00],
    '-': [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
    '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
    ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    
    # MAIÚSCULAS
    'A': [0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
    'B': [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00],
    'C': [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00],
    'D': [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00],
    'E': [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00],
    'F': [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00],
    'G': [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00],
    'H': [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
    'I': [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
    'J': [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00],
    'K': [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00],
    'L': [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00],
    'M': [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00],
    'N': [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00],
    'O': [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
    'P': [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00],
    'Q': [0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00],
    'R': [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00],
    'S': [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00],
    'T': [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
    'U': [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
    'V': [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
    'W': [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],
    'X': [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00],
    'Y': [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00],
    'Z': [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00],
    
    # MINÚSCULAS
    'a': [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00],
    'b': [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00],
    'c': [0x00, 0x00, 0x3C, 0x60, 0x60, 0x60, 0x3C, 0x00],
    'd': [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00],
    'e': [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00],
    'f': [0x0E, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00],
    'g': [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x7C],
    'h': [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00],
    'i': [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00],
    'j': [0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x66, 0x3C],
    'k': [0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00],
    'l': [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
    'm': [0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00],
    'n': [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00],
    'o': [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00],
    'p': [0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60],
    'q': [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06],
    'r': [0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00],
    's': [0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00],
    't': [0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x0E, 0x00],
    'u': [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00],
    'v': [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
    'w': [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00],
    'x': [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00],
    'y': [0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x0C, 0x78],
    'z': [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00],
}

def draw_char(x, y, char, color, size):
    if not display_on or char not in font: return
    bitmap = font[char]
    for row in range(8):
        byte = bitmap[row]
        for col in range(8):
            if byte & (0x80 >> col):
                fill_rect(x + col*size, y + row*size, size, size, color)

def draw_text(x, y, text, color, size):
    if not display_on: return
    for i, c in enumerate(text):
        draw_char(x + i*(8*size + 2*size), y, c.upper(), color, size)

def draw_centered(y, text, color, size):
    if not display_on: return
    w = len(text) * (8*size + 2*size) - 2*size
    x = (480 - w) // 2
    draw_text(x, y, text, color, size)

# === BLE ===
class BLE:
    def __init__(self):
        try:
            self.ble = ubluetooth.BLE()
            self.ble.active(True)
            self.ble.irq(self._irq)
            char = (ubluetooth.UUID("00002a00-0000-1000-8000-00805f9b34fb"), ubluetooth.FLAG_WRITE)
            svc = (ubluetooth.UUID("00001800-0000-1000-8000-00805f9b34fb"), (char,))
            ((self.h,),) = self.ble.gatts_register_services((svc,))
            self.ble.gap_advertise(100, b'\x02\x01\x06\x0c\x09MagicMirror')
        except: pass
    
    def _irq(self, e, d):
        global ble_connected, events
        try:
            if e == 1: ble_connected = True
            elif e == 2: ble_connected = False; self.ble.gap_advertise(100, b'\x02\x01\x06\x0c\x09MagicMirror')
            elif e == 3:
                msg = self.ble.gatts_read(self.h).decode().strip()
                if msg and '{' in msg:
                    j = ujson.loads(msg)
                    if j.get('action') == 'sync_events':
                        events = j.get('events', [])[:5]
        except: pass

# === CONTROLES DE MUDANÇA ===
last_time = {'h': None, 'm': None, 's': None}
last_date = {'d': None, 'm': None, 'y': None}
last_event = {'nome': None, 'hora': None}
last_ble = None
last_btn = 1

def get_next_event():
    if not events: return None
    try:
        t = rtc.datetime()
        now_min = t[4] * 60 + t[5]
        for event in events:
            if 'hora' in event:
                h, m = map(int, event['hora'].split(':'))
                if h * 60 + m >= now_min:
                    return event
        return events[0]
    except:
        return events[0] if events else None

def update_display():
    global last_time, last_date, last_event, last_ble
    if not display_on: return
    
    t = rtc.datetime()
    h, m, s = t[4], t[5], t[6]
    d, mo, y = t[2], t[1], t[0]
    
    # POSIÇÕES CORRIGIDAS PARA CENTRALIZAR O RELÓGIO
    pos_h = 80      # Posição das horas
    pos_c1 = 160    # Primeiro dois pontos
    pos_m = 200     # Posição dos minutos  
    pos_c2 = 280    # Segundo dois pontos
    pos_s = 320     # Posição dos segundos
    
    # ATUALIZA SÓ DÍGITOS QUE MUDARAM
    if h != last_time['h']:
        fill_rect(pos_h, 80, 80, 40, BLACK)
        draw_text(pos_h, 80, f"{h:02d}", WHITE, 4)
        last_time['h'] = h
    
    if m != last_time['m']:
        fill_rect(pos_m, 80, 80, 40, BLACK)
        draw_text(pos_m, 80, f"{m:02d}", WHITE, 4)
        last_time['m'] = m
    
    if s != last_time['s']:
        fill_rect(pos_s, 80, 80, 40, BLACK)
        draw_text(pos_s, 80, f"{s:02d}", WHITE, 4)
        last_time['s'] = s
    
    # ATUALIZA DATA (SÓ QUANDO MUDA) - Embaixo do relógio
    if d != last_date['d'] or mo != last_date['m'] or y != last_date['y']:
        fill_rect(120, 140, 240, 25, BLACK)
        draw_centered(140, f"{d:02d}/{mo:02d}/{y}", WHITE, 2)
        last_date = {'d': d, 'm': mo, 'y': y}
    
    # ATUALIZA BLE STATUS (SÓ QUANDO MUDA)
    if ble_connected != last_ble:
        fill_rect(10, 10, 40, 20, BLACK)
        draw_text(10, 10, "BLE", GREEN if ble_connected else RED, 2)
        last_ble = ble_connected
    
    # ATUALIZA EVENTO (SÓ QUANDO MUDA)
    evt = get_next_event()
    evt_nome = evt.get('nome', '') if evt else ''
    evt_hora = evt.get('hora', '') if evt else ''
    
    if evt_nome != last_event['nome'] or evt_hora != last_event['hora']:
        fill_rect(50, 180, 380, 60, BLACK)
        if evt:
            draw_centered(180, "EVENTO DO DIA", CYAN, 2)
            if evt_hora:
                draw_centered(205, evt_hora, YELLOW, 2)
            if evt_nome:
                nome_curto = evt_nome[:25]
                draw_centered(230, nome_curto, WHITE, 2)
        else:
            draw_centered(200, "SEM EVENTOS HOJE", WHITE, 2)
        
        last_event = {'nome': evt_nome, 'hora': evt_hora}

def check_button():
    global last_btn, display_on, last_time, last_date, last_event, last_ble
    b = btn.value()
    if last_btn == 1 and b == 0:
        display_on = not display_on
        if display_on:
            fill_rect(0, 0, 480, 320, BLACK)
            draw_text(160, 80, ":", WHITE, 4)
            draw_text(280, 80, ":", WHITE, 4)
            last_time = {'h': None, 'm': None, 's': None}
            last_date = {'d': None, 'm': None, 'y': None}
            last_event = {'nome': None, 'hora': None}
            last_ble = None
        else:
            fill_rect(0, 0, 480, 320, BLACK)
    last_btn = b

# === INICIALIZAÇÃO ===
print("Inicializando LCD...")
init_lcd()

print("Tela de inicialização...")
fill_rect(0, 0, 480, 320, BLACK)
draw_centered(100, "MAGIC MIRROR", WHITE, 4)
draw_centered(150, "CONECTANDO WIFI...", CYAN, 2)
utime.sleep(2)

print("Preparando interface...")
fill_rect(0, 0, 480, 320, BLACK)
draw_text(160, 80, ":", WHITE, 4)
draw_text(280, 80, ":", WHITE, 4)

print("Iniciando BLE...")
ble = BLE()

print("PRONTO!")

# === LOOP PRINCIPAL ===
while True:
    try:
        check_button()
        update_display()
        utime.sleep_ms(200)
        gc.collect()
    except Exception as e:
        print(f"Erro: {e}")
        utime.sleep(1)